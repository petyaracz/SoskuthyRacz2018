filter(behaviour=="b") %>%
dplyr::select(-behaviour, -n)
exp_by_word_props
sim_matrix <- sim.matrix
# setting number of iterations
iterations = 10000
# prediction probabilities for whole data set (conditioned on participant but not item)
preds <- predict(exp_mod_full, exp_data,
re.form=~(1 + filledO1.fact + voicedO2.fact | participant),
type="response")
# setting up matrix that will store the results of the simulation
sim_matrix <- matrix(rep(0,iterations*48), nrow=48)
rownames(sim_matrix) <- names(tapply(exp_data$behaviour=="b", exp_data$item, FUN=mean))
# running the simulation
for (i in 1:iterations) {
# sampling from binomial distribution
outcomes <- rbinom(n=preds, size=1, prob=preds)
# calculating proportion of b (vs. m) for each item in a given iteration
sim_matrix[,i] <- tapply(outcomes, exp_data$item, FUN=mean)
# progress indicator
if (i %% 100 == 0) {cat("\r               \r", i)}
}
# calculating mean and confidence interval and storing it in a data frame
sim_pred <- apply(sim_matrix, 1, mean)
sim_lower <- apply(sim_matrix, 1, quantile, 0.025)
sim_upper <- apply(sim_matrix, 1, quantile, 0.975)
sim_dat <- data.frame(item=rownames(sim_matrix), fit=sim_pred, lower=sim_lower, upper=sim_upper)
exp_by_word_props <- exp_data %>%
dplyr::count(item, filledO1, voicedO2, behaviour) %>%
group_by(item) %>%
mutate(prop = prop.table(n)) %>%
ungroup() %>%
filter(behaviour=="b") %>%
dplyr::select(-behaviour, -n)
# joining proportions in raw data and predictions / confidence intervals from model
exp_by_word_props <- left_join(exp_by_word_props, sim_dat, by="summary")
# joining proportions in raw data and predictions / confidence intervals from model
exp_by_word_props <- left_join(exp_by_word_props, sim_dat, by="item")
exp_by_word_props
exp_by_word_props <- exp_data %>%
dplyr::count(item, ipa, filledO1, voicedO2, behaviour) %>%
group_by(item) %>%
mutate(prop = prop.table(n)) %>%
ungroup() %>%
filter(behaviour=="b") %>%
dplyr::select(-behaviour, -n)
exp_by_word_props
# ordering grouping factor for plot (ipa transcription) by proportion of [b] behaviour
# within each combination of filledO1 and voicedO2
exp_by_word_props_levels <- unique(exp_by_word_props$ipa)
exp_by_word_props_levels <- exp_by_word_props_levels[with(exp_by_word_props, order(filledO1, voicedO2, prop))]
exp_by_word_props$ipa <- factor(exp_by_word_props$ipa, levels=exp_by_word_props_levels)
exp_by_word_props$ipa
# proportions in raw data
exp_by_word_props <- exp_data %>%
dplyr::count(item, ipa, filledO1, voicedO2, behaviour) %>%
group_by(item) %>%
mutate(prop = prop.table(n)) %>%
ungroup() %>%
filter(behaviour=="b") %>%
dplyr::select(-behaviour, -n)
# joining proportions in raw data and predictions / confidence intervals from model
exp_by_word_props <- left_join(exp_by_word_props, sim_dat, by="item")
# ordering grouping factor for plot (ipa transcription) by proportion of [b] behaviour
# within each combination of filledO1 and voicedO2
exp_by_word_props_levels <- unique(exp_by_word_props$ipa)
exp_by_word_props_levels <- exp_by_word_props_levels[with(exp_by_word_props, order(filledO1, voicedO2, prop))]
exp_by_word_props$ipa <- factor(exp_by_word_props$ipa, levels=exp_by_word_props_levels)
# creating meaningful labels for graph
exp_by_word_props$filledO1 <- ifelse(exp_by_word_props$filledO1, "filled O1", "empty O1")
exp_by_word_props$voicedO2 <- ifelse(exp_by_word_props$voicedO2, "+voi O2", "–voi O2")
exp_by_word_props$combined_pred <- paste(exp_by_word_props$filledO1, exp_by_word_props$voicedO2, sep=", ")
exp_by_word_props$combined_pred <- factor(exp_by_word_props$combined_pred, levels=c(
"empty O1, +voi O2",
"empty O1, –voi O2",
"filled O1, +voi O2",
"filled O1, –voi O2")
)
# the final ggplot
ggplot(exp_by_word_props, aes(x=ipa, y=prop)) +
# faceting by filledO1 & voicedO2
facet_grid(~combined_pred, scales = "free", space = "free") +
# bars for raw proportions
geom_bar(stat="identity",fill="deepskyblue3") +
# model predictions
geom_errorbar(aes(ymax = upper, ymin = lower), position = position_dodge(), width = 0.5) +
geom_point(aes(y=fit)) +
# formatting
ylim(c(0,1)) +
ylab("proportion of [b] behaviour") + xlab("") +
theme_bw() +
theme(axis.text.x = element_text(angle=60, hjust=1, size=10),
axis.text.y=element_text(size=12),
axis.title.x=element_blank(),
axis.title.y=element_text(size=14,face="bold"),
strip.text=element_text(size=12),
plot.title=element_text(size=14,face="bold")) +
ggtitle(paste0("by-item raw proportions and simulated predictions"))
cairo_pdf
?cairo_pdf
# full glm with naive gcm prediction probabilities included
corp_mod_naive_full <- glm(behaviour ~ filledO1 + voiced_second_consonant + gcm_naive, data=corp_data, family="binomial")
# full glm with naive gcm prediction probabilities included
corp_mod_naive_full <- glm(behaviour ~ filledO1 + voiced_second_consonant + gcm_naive, data=corp_data, family="binomial")
corp_mod_naive_min_voiced_second_consonant <- update(corp_mod_naive_full, .~. -voiced_second_consonant)
corp_mod_naive_min_gcm <- update(corp_mod_naive_full, .~. -gcm_naive)
anova(corp_mod_naive_full, corp_mod_naive_min_filledO1, test="Chisq")
corp_mod_naive_min_filledO1 <- update(corp_mod_naive_full, .~. -filledO1)
corp_mod_naive_min_voiced_second_consonant <- update(corp_mod_naive_full, .~. -voiced_second_consonant)
corp_mod_naive_min_gcm <- update(corp_mod_naive_full, .~. -gcm_naive)
anova(corp_mod_naive_full, corp_mod_naive_min_filledO1, test="Chisq")
anova(corp_mod_naive_full, corp_mod_naive_min_voiced_second_consonant, test="Chisq")
anova(corp_mod_naive_full, corp_mod_naive_min_gcm, test="Chisq")
colnames(corp_data)
# full glm with naive gcm prediction probabilities included
corp_mod_inf_full <- glm(behaviour ~ filledO1 + voiced_second_consonant + gcm_inf, data=corp_data, family="binomial")
# fitting nested models
corp_mod_inf_min_filledO1 <- update(corp_mod_inf_full, .~. -filledO1)
corp_mod_inf_min_voiced_second_consonant <- update(corp_mod_inf_full, .~. -voiced_second_consonant)
corp_mod_inf_min_gcm <- update(corp_mod_inf_full, .~. -gcm_inf)
# model comparisons
anova(corp_mod_inf_full, corp_mod_inf_min_filledO1, test="Chisq")
anova(corp_mod_inf_full, corp_mod_inf_min_voiced_second_consonant, test="Chisq")
anova(corp_mod_inf_full, corp_mod_inf_min_gcm, test="Chisq")
library(GGally)
# setting various parameters for plot
lims <- list(O1_diff=c(-0.5,0.5),
O2_diff=c(-0.5,0.5),
overall=c(0,1))
density.tops <- list(O1_diff=3.03,
O2_diff=3.05,
overall=3.2)
centres <- list(O1_diff=0,
O2_diff=0,
overall=0.5)
text.targets <- list(O1_diff=1.2,
O2_diff=1.2,
overall=1.7)
breakss <- list(O1_diff=c(-0.4,-0.2,0,0.2,0.4),
O2_diff=c(-0.4,-0.2,0,0.2,0.4),
overall=c(0,0.25,0.5,0.75,1))
break.labs <- list(O1_diff=c("–0.4","–0.2","0","0.2","0.4"),
O2_diff=c("–0.4","–0.2","0","0.2","0.4"),
overall=c("0","0.25","0.5","0.75","1"))
# custom function for creating the individual 2d density plots
density2d <- function(data, mapping, ..., low = "dodgerblue4", high = "deepskyblue1") {
x.mean <- mean(as.data.frame(data)[,as.character(mapping$x)])
y.mean <- mean(as.data.frame(data)[,as.character(mapping$y)])
x.lim <- lims[[as.character(mapping$x)]]
y.lim <- lims[[as.character(mapping$y)]]
x.centre <- centres[[as.character(mapping$x)]]
y.centre <- centres[[as.character(mapping$y)]]
x.breaks <- breakss[[as.character(mapping$x)]]
y.breaks <- breakss[[as.character(mapping$y)]]
x.break.labs <- break.labs[[as.character(mapping$x)]]
y.break.labs <- break.labs[[as.character(mapping$y)]]
ggplot(data = data, mapping = mapping) +
stat_density_2d(aes(fill = ..level..), geom="polygon", bins=20, h=c(0.2,0.2)) +
geom_hline(yintercept=y.centre, lty=2, alpha=0.4) +
geom_vline(xintercept=x.centre, lty=2, alpha=0.4) +
annotate("text", label="baseline", x=x.lim[2], y=y.centre - (y.lim[2]-y.lim[1])*0.02,
vjust="top", hjust="right", alpha=0.4) +
annotate("text", label="baseline", x=x.centre + (x.lim[2]-x.lim[1])*0.02, y=y.lim[2],
vjust="bottom", hjust="left", alpha=0.4, angle=270) +
geom_point(x=x.mean, y=y.mean, pch=3, cex=2) +
annotate("text", label="mean", x=x.mean, y=y.mean - (y.lim[2]-y.lim[1])*0.05,
vjust="top", hjust="centre") +
#xlim(x.lim[1], x.lim[2]) +
#ylim(y.lim[1], y.lim[2]) +
scale_x_continuous(breaks=x.breaks, labels=x.break.labs, limits=x.lim) +
scale_y_continuous(breaks=y.breaks, labels=y.break.labs, limits=y.lim) +
scale_fill_gradient(low = low, high = high) + theme_bw() +
theme(panel.grid.minor=element_blank(),
panel.grid.major=element_blank())
}
# custom function for 1d density plots
density1d <- function(data, mapping) {
#print(as.data.frame(data))
x.mean <- mean(as.data.frame(data)[,as.character(mapping$x)])
x.centre <- centres[[as.character(mapping$x)]]
y.text <- text.targets[[as.character(mapping$x)]]
x.lim <- lims[[as.character(mapping$x)]]
x.breaks <- breakss[[as.character(mapping$x)]]
x.break.labs <- break.labs[[as.character(mapping$x)]]
density.top <- density.tops[[as.character(mapping$x)]]
ggplot(data = data, mapping = mapping) +
stat_density(fill="firebrick3") +
geom_vline(xintercept=x.centre, lty=2, alpha=0.4) +
annotate("text", label="baseline", x=x.centre + (x.lim[2]-x.lim[1])*0.02, y=density.top,
vjust="bottom", hjust="left", alpha=0.4, angle=270) +
geom_point(x=x.mean, y=y.text, pch=3, cex=2) +
annotate("text", label="mean", x=x.mean, y=y.text - 0.15,
vjust="top", hjust="centre") +
scale_y_continuous(breaks=NULL) +
theme_bw() +
scale_x_continuous(breaks=x.breaks, labels=x.break.labs, limits=x.lim) +
theme(panel.grid.minor=element_blank(),
panel.grid.major=element_blank())
}
# for displaying correlation values
ggcor <- function (data, mapping) {
mapping$size <- 6
p <- ggally_cor(data=data, mapping=mapping)
p <- p + theme_bw() +
theme(panel.grid.minor=element_blank(),
panel.grid.major=element_blank())
}
# creating the actual pair plot
p <- ggpairs(exp_by_part_prop,
columns=c("overall","O1_diff","O2_diff"),
columnLabels=c("overall % [b]",
"filled – empty O1 % [b]",
"[+voi] – [–voi] O2 % [b]"),
# plugging in custom functions
lower = list(continuous = density2d),
diag = list(continuous = density1d),
upper = list(continuous = ggcor)
)
# calculating...
# 1) overall proportion of [b] echo behaviour for each speaker
# 2) proportions of [b] when O1 is filled vs when it's empty for each speaker
# 3) proportions of [b] when O2 is voiced vs when it's voiceless for each speaker
exp_by_part_prop <-
exp_data %>%
dplyr::group_by(participant) %>%
dplyr::summarise(voicedO2_yes=mean(behaviour[voicedO2]=="b"),
voicedO2_no=mean(behaviour[!voicedO2]=="b"),
filledO1_yes=mean(behaviour[filledO1]=="b"),
filledO1_no=mean(behaviour[!filledO1]=="b"),
overall=mean(behaviour=="b"))
# adding difference values (cf. section 5 of the paper)
exp_by_part_prop <- as.data.frame(exp_by_part_prop)
exp_by_part_prop <- exp_by_part_prop[!is.na(exp_by_part_prop$filledO1_no),]
exp_by_part_prop$O1_diff <- exp_by_part_prop$filledO1_yes - exp_by_part_prop$filledO1_no
exp_by_part_prop$O2_diff <- exp_by_part_prop$voicedO2_yes - exp_by_part_prop$voicedO2_no
library(GGally)
# setting various parameters for plot
lims <- list(O1_diff=c(-0.5,0.5),
O2_diff=c(-0.5,0.5),
overall=c(0,1))
density.tops <- list(O1_diff=3.03,
O2_diff=3.05,
overall=3.2)
centres <- list(O1_diff=0,
O2_diff=0,
overall=0.5)
text.targets <- list(O1_diff=1.2,
O2_diff=1.2,
overall=1.7)
breakss <- list(O1_diff=c(-0.4,-0.2,0,0.2,0.4),
O2_diff=c(-0.4,-0.2,0,0.2,0.4),
overall=c(0,0.25,0.5,0.75,1))
break.labs <- list(O1_diff=c("–0.4","–0.2","0","0.2","0.4"),
O2_diff=c("–0.4","–0.2","0","0.2","0.4"),
overall=c("0","0.25","0.5","0.75","1"))
# custom function for creating the individual 2d density plots
density2d <- function(data, mapping, ..., low = "dodgerblue4", high = "deepskyblue1") {
x.mean <- mean(as.data.frame(data)[,as.character(mapping$x)])
y.mean <- mean(as.data.frame(data)[,as.character(mapping$y)])
x.lim <- lims[[as.character(mapping$x)]]
y.lim <- lims[[as.character(mapping$y)]]
x.centre <- centres[[as.character(mapping$x)]]
y.centre <- centres[[as.character(mapping$y)]]
x.breaks <- breakss[[as.character(mapping$x)]]
y.breaks <- breakss[[as.character(mapping$y)]]
x.break.labs <- break.labs[[as.character(mapping$x)]]
y.break.labs <- break.labs[[as.character(mapping$y)]]
ggplot(data = data, mapping = mapping) +
stat_density_2d(aes(fill = ..level..), geom="polygon", bins=20, h=c(0.2,0.2)) +
geom_hline(yintercept=y.centre, lty=2, alpha=0.4) +
geom_vline(xintercept=x.centre, lty=2, alpha=0.4) +
annotate("text", label="baseline", x=x.lim[2], y=y.centre - (y.lim[2]-y.lim[1])*0.02,
vjust="top", hjust="right", alpha=0.4) +
annotate("text", label="baseline", x=x.centre + (x.lim[2]-x.lim[1])*0.02, y=y.lim[2],
vjust="bottom", hjust="left", alpha=0.4, angle=270) +
geom_point(x=x.mean, y=y.mean, pch=3, cex=2) +
annotate("text", label="mean", x=x.mean, y=y.mean - (y.lim[2]-y.lim[1])*0.05,
vjust="top", hjust="centre") +
#xlim(x.lim[1], x.lim[2]) +
#ylim(y.lim[1], y.lim[2]) +
scale_x_continuous(breaks=x.breaks, labels=x.break.labs, limits=x.lim) +
scale_y_continuous(breaks=y.breaks, labels=y.break.labs, limits=y.lim) +
scale_fill_gradient(low = low, high = high) + theme_bw() +
theme(panel.grid.minor=element_blank(),
panel.grid.major=element_blank())
}
# custom function for 1d density plots
density1d <- function(data, mapping) {
#print(as.data.frame(data))
x.mean <- mean(as.data.frame(data)[,as.character(mapping$x)])
x.centre <- centres[[as.character(mapping$x)]]
y.text <- text.targets[[as.character(mapping$x)]]
x.lim <- lims[[as.character(mapping$x)]]
x.breaks <- breakss[[as.character(mapping$x)]]
x.break.labs <- break.labs[[as.character(mapping$x)]]
density.top <- density.tops[[as.character(mapping$x)]]
ggplot(data = data, mapping = mapping) +
stat_density(fill="firebrick3") +
geom_vline(xintercept=x.centre, lty=2, alpha=0.4) +
annotate("text", label="baseline", x=x.centre + (x.lim[2]-x.lim[1])*0.02, y=density.top,
vjust="bottom", hjust="left", alpha=0.4, angle=270) +
geom_point(x=x.mean, y=y.text, pch=3, cex=2) +
annotate("text", label="mean", x=x.mean, y=y.text - 0.15,
vjust="top", hjust="centre") +
scale_y_continuous(breaks=NULL) +
theme_bw() +
scale_x_continuous(breaks=x.breaks, labels=x.break.labs, limits=x.lim) +
theme(panel.grid.minor=element_blank(),
panel.grid.major=element_blank())
}
# for displaying correlation values
ggcor <- function (data, mapping) {
mapping$size <- 6
p <- ggally_cor(data=data, mapping=mapping)
p <- p + theme_bw() +
theme(panel.grid.minor=element_blank(),
panel.grid.major=element_blank())
}
# creating the actual pair plot
p <- ggpairs(exp_by_part_prop,
columns=c("overall","O1_diff","O2_diff"),
columnLabels=c("overall % [b]",
"filled – empty O1 % [b]",
"[+voi] – [–voi] O2 % [b]"),
# plugging in custom functions
lower = list(continuous = density2d),
diag = list(continuous = density1d),
upper = list(continuous = ggcor)
)
# formatting
p <- p + theme(axis.title=element_text(size=14, face="bold"),
axis.text=element_text(size=12),
strip.text=element_text(size=12),
legend.title=element_text(size=14,face="bold"),
legend.text=element_text(size=12),
plot.title=element_text(size=14,face="bold"))
#cairo_pdf("by_participant.pdf", width=8.5, height=8)
p
#dev.off()
ages("random")
install.packages("random")
library(devtools)
install_git("https://github.com/soskuthy/rgcm")
library(rgcm)
?gcm
?default.proprs
?default.priors
# using default priors for rgcm
new.priors <- default.priors
# ... but changing the prior for the precision parameter to 13.06 manually
# (determined from previous exploration)
new.priors$c <- quote(13.06)
set.seed(123) # for exact replicability
?gcm
library(tidyverse)
exp_data <- read_csv("exp_data.csv")
corp_data <- read_csv("echo_pair_corpus.csv")
# so that "m" is unmarked and "b" is marked in stats & graphs
exp_data$behaviour <- factor(exp_data$behaviour, levels=c("m","b"))
corp_data$behaviour <- factor(corp_data$behaviour, levels=c("m","b"))
# removing .s from colnames for consistency
colnames(exp_data) <- gsub("[.]", "_", colnames(exp_data))
colnames(corp_data) <- gsub("[.]", "_", colnames(corp_data))
# using default priors for rgcm
new.priors <- default.priors
# ... but changing the prior for the precision parameter to 13.06 manually
# (determined from previous exploration)
new.priors$c <- quote(13.06)
set.seed(123) # for exact replicability
corp_gcm <- gcm(behaviour ~ O1 + N1 + C1 + O2 + N2 + C2,
data=corp_data, parallel=2,
priors=new.priors)
corp_data
corp_gcm <- gcm(behaviour ~ O1 + N1 + C1 + O2 + N2 + C2,
data=corp_data, parallel=2,
priors=new.priors)
corp_gcm <- gcm(behaviour ~ O1 + N1 + C1 + O2 + N2 + C2,
data=as.data.frame(corp_data), parallel=2,
priors=new.priors)
newpars <- predict(corp_gcm, sample.type="mean")$predictions[[1]]$parameters
newpars
?predict.gcm
# adding predictors to experimental data
gcm.naive.preds <- predict(cica.gcm, newtest=as.data.frame(exp_data), user.samples=newpars, type="probabilities")$predictions[[1]]$outcome
# adding predictors to experimental data
gcm.naive.preds <- predict(corp_gcm, newtest=as.data.frame(exp_data), user.samples=newpars, type="probabilities")$predictions[[1]]$outcome
# a mini data set which has a single row for each stimulus (so 48 rows altogether)
exp_stim <- unique(select(exp_data, item, O1, N1, C1, O2, N2, C2))
exp_stim
# adding predictors to experimental data
gcm.naive.preds <- predict(corp_gcm, newtest=as.data.frame(exp_stim), user.samples=newpars, type="probabilities")$predictions[[1]]$outcome
# a mini data set which has a single row for each stimulus (so 48 rows altogether)
exp_stim <- exp_data %>%
select(item, O1, N1, C1, O2, N2, C2) %>%
unique %>%
mutate(behaviour="b")
exp_stim
# adding predictors to experimental data
gcm.naive.preds <- predict(corp_gcm, newtest=as.data.frame(exp_stim), user.samples=newpars, type="probabilities")$predictions[[1]]$outcome
gcm.inf.preds <- predict(cica.gcm, newtest=as.data.frame(exp_stim), sample.type="mean", type="probabilities")$predictions[[1]]$outcome
# adding predictors to experimental data
# 1) for the naive predictions, we supply naive_pars as
#    the parameters to condition the predictions on
gcm.naive.preds <- predict(corp_gcm, newtest=as.data.frame(exp_stim), user.samples=naive_pars, type="probabilities")$predictions[[1]]$outcome
# creating parameter values for the naive model
naive_pars <- predict(corp_gcm, sample.type="mean")$predictions[[1]]$parameters
# creating parameter values for the naive model
naive_pars <- predict(corp_gcm, sample.type="mean")$predictions[[1]]$parameters
naive_pars["b[1]"] <- 0.5
naive_pars["b[1]"] <- 0.5
naive_pars["b[2]"] <- 0.5
naive_pars["w[1]"] <- 1/6
naive_pars["w[3]"] <- 1/6
naive_pars["w[4]"] <- 1/6
naive_pars["w[5]"] <- 1/6
naive_pars["w[6]"] <- 1/6
# adding predictors to experimental data
# 1) for the naive predictions, we supply naive_pars as
#    the parameters to condition the predictions on
gcm.naive.preds <- predict(corp_gcm, newtest=as.data.frame(exp_stim), user.samples=naive_pars, type="probabilities")$predictions[[1]]$outcome
# 2) for the informed predictions, we simply use the
#    mean values of the parameters from the MCMC samples
gcm.inf.preds <- predict(corp_gcm, newtest=as.data.frame(exp_stim), sample.type="mean", type="probabilities")$predictions[[1]]$outcome
gcm.naive.preds
library(arm)
# we now add the logit transformed probabilities to the mini data set
exp_stim$gcm_naive <- logit(gcm_naive_preds[,2])
exp_stim$gcm_inf <- logit(gcm_inf_preds[,2])
# adding predictors to experimental data
# 1) for the naive predictions, we supply naive_pars as
#    the parameters to condition the predictions on
gcm_naive_preds <- predict(corp_gcm, newtest=as.data.frame(exp_stim), user.samples=naive_pars, type="probabilities")$predictions[[1]]$outcome
# 2) for the informed predictions, we simply use the
#    mean values of the parameters from the MCMC samples
gcm_inf_preds <- predict(corp_gcm, newtest=as.data.frame(exp_stim), sample.type="mean", type="probabilities")$predictions[[1]]$outcome
# we now add the logit transformed probabilities to the mini data set
exp_stim$gcm_naive <- logit(gcm_naive_preds[,2])
exp_stim$gcm_inf <- logit(gcm_inf_preds[,2])
# and we merge the mini data set with the experimental data
exp_data <- merge(exp_data, exp_stim[,c("item","gcm_naive", "gcm_inf")], by="item")
# a mini data set which has a single row for each stimulus (so 48 rows altogether)
exp_stim <- exp_data %>%
select(item, O1, N1, C1, O2, N2, C2) %>%
unique %>%
mutate(behaviour="b")
# adding predictors to experimental data
# 1) for the naive predictions, we supply naive_pars as
#    the parameters to condition the predictions on
gcm_naive_exp_preds <- predict(corp_gcm, newtest=as.data.frame(exp_stim), user.samples=naive_pars, type="probabilities")$predictions[[1]]$outcome
# 2) for the informed predictions, we simply use the
#    mean values of the parameters from the MCMC samples
gcm_inf_exp_preds <- predict(corp_gcm, newtest=as.data.frame(exp_stim), sample.type="mean", type="probabilities")$predictions[[1]]$outcome
# we now add the logit transformed probabilities to the mini data set
exp_stim$gcm_naive <- logit(gcm_naive_exp_preds[,2])
exp_stim$gcm_inf <- logit(gcm_inf_exp_preds[,2])
# and we merge the mini data set with the experimental data
exp_data <- merge(exp_data, exp_stim[,c("item","gcm_naive", "gcm_inf")], by="item")
# adding predictors to corpus data
# 1) for the naive predictions, we supply naive_pars as
#    the parameters to condition the predictions on
gcm_naive_corp_preds <- predict(corp_gcm, type="probabilities", user.samples=naive_pars)$predictions[[1]]$outcome[,2]
gcm_naive_corp_preds
# adding predictors to corpus data
# 1) for the naive predictions, we supply naive_pars as
#    the parameters to condition the predictions on
gcm_naive_corp_preds <- predict(corp_gcm, user.samples=naive_pars,
type="probabilities")$predictions[[1]]$outcome[,2]
# 2) for the informed predictions, we simply use the
#    mean values of the parameters from the MCMC samples
gcm_inf_corp_preds <- predict(corp_gcm, sample.type="mean",
type="probabilities")$predictions[[1]]$outcome[,2]
library(tidyverse)
library(arm)
exp_data <- read_csv("exp_data.csv")
corp_data <- read_csv("echo_pair_corpus.csv")
# so that "m" is unmarked and "b" is marked in stats & graphs
exp_data$behaviour <- factor(exp_data$behaviour, levels=c("m","b"))
corp_data$behaviour <- factor(corp_data$behaviour, levels=c("m","b"))
# removing .s from colnames for consistency
colnames(exp_data) <- gsub("[.]", "_", colnames(exp_data))
colnames(corp_data) <- gsub("[.]", "_", colnames(corp_data))
install.packages("random")
library(devtools)
install_git("https://github.com/soskuthy/rgcm")
library(rgcm)
# using default priors for rgcm
new_priors <- default_priors
library(tidyverse)
library(arm)
exp_data <- read_csv("exp_data.csv")
corp_data <- read_csv("echo_pair_corpus.csv")
# so that "m" is unmarked and "b" is marked in stats & graphs
exp_data$behaviour <- factor(exp_data$behaviour, levels=c("m","b"))
corp_data$behaviour <- factor(corp_data$behaviour, levels=c("m","b"))
# removing .s from colnames for consistency
colnames(exp_data) <- gsub("[.]", "_", colnames(exp_data))
colnames(corp_data) <- gsub("[.]", "_", colnames(corp_data))
install.packages("random")
library(devtools)
install_git("https://github.com/soskuthy/rgcm")
library(rgcm)
# using default priors for rgcm
new_priors <- default.priors
# ... but changing the prior for the precision parameter to 13.06 manually
# (determined from previous exploration)
new_priors$c <- quote(13.06)
set.seed(123) # for exact replicability
# rgcm does not seem happy with tidy data frames, so we need to convert corp_data back to
# a traditional one
corp_gcm <- gcm(behaviour ~ O1 + N1 + C1 + O2 + N2 + C2,
data=as.data.frame(corp_data), parallel=2,
priors=new.priors)
